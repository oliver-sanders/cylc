#!/usr/bin/env python
# THIS FILE IS PART OF THE CYLC SUITE ENGINE.
# Copyright (C) 2008-2017 NIWA
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""Orchestrates experiments to profile the performance of cylc at different
versions."""

import glob
import hashlib
import itertools
import json
import optparse
import os
import random
import re
import shutil
import socket
import sys
import time

# Write out floats to one decimal place only.
from json import encoder
encoder.FLOAT_REPR = lambda o: format(o, '.1f')

import cylc.profiling as prof
import cylc.profiling.analysis as analysis
import cylc.profiling.git as git
from cylc.profiling.profile import profile
import cylc.profiling.results as results

RUN_DOC = r"""cylc profile-battery [-e [EXPERIMENT ...]] [-v [VERSION ...]]

TODO: This!

Run profiling experiments against different versions of cylc. A list of
experiments can be specified after the -e flag, if not provided the experiment
"complex" will be chosen. A list of versions to profile against can be
specified after the -v flag, if not provided the current version will be used.

Experiments are stored in dev/profile-experiments, user experiments can be
stored in .profiling/experiments. Experiments are specified without the file
extension, experiments in .profiling/ will be chosen before those in dev/.

    Note: See dev/profile-experiments/example for an experiment template with
          further details.

Versions are any valid git identifiers i.e. tags, branches, commits.

Profiling will save results to .profiling/results.json where they can be used
for future comparisons. To list profiling results run:
    * cylc profile-battery --ls  # list all results
    * cylc profile-battery --ls -e experiment  # list all results for
                                               # experiment "experiment".
    * cylc profile-battery --ls --delete -v  6.1.2  # Delete all results for
                                                    # version 6.1.2 (prompted).

If matplotlib and numpy are installed profiling generates plots which are
saved to .profiling/plots or presented in an interactive window using the -i
flag.

Results are stored along with a checksum for the experiment file. When an
experiment file is changed previous results are maintained, future results will
be stored separately. To copy results from an older version of an experiment
into those from the current one run:
    * cylc profile-battery --promote experiment@checksum

    Note: At present results cannot be analysed without the experiment file so
          old results must be "copied" in this way to be re-used.

The results output contain only a small number of metrics, to see a full list
of results use the --full option.

"""


def create_profile_directory():
    """Creates a directory for storing results and user experiments in."""
    profile_dir = os.path.join(prof.CYLC_DIR, prof.PROFILE_DIR_NAME)
    os.mkdir(profile_dir)
    os.mkdir(os.path.join(profile_dir, prof.PROFILE_PLOT_DIR_NAME))
    os.mkdir(os.path.join(profile_dir, prof.USER_EXPERIMENT_DIR_NAME))
    print 'creating', os.path.join(profile_dir, prof.PROFILE_FILE_NAME)
    with open(os.path.join(profile_dir, prof.PROFILE_FILE_NAME),
              'w+') as profile_file:
        profile_file.write('{}')


def parse_args():
    """Parse command line arguments for this script."""
    def multi_arg_callback(option, _, value, parser):
        """Allows an unkonwn number of arguments to be passed as an option."""
        assert value is None
        value = []
        for arg in parser.rargs:
            if arg[0] == '-':
                break
            value.append(arg)
        del parser.rargs[:len(value)]
        setattr(parser.values, option.dest, value)

    parser = optparse.OptionParser(RUN_DOC)
    parser.add_option('-e', '--experiments',
                      help='Specify list of experiments to run.',
                      dest='experiments', callback=multi_arg_callback,
                      action='callback')
    parser.add_option('-v', '--versions',
                      help='Specify cylc versions to profile. Git tags, ' +
                      'branches, commits are all valid.',
                      dest='versions', callback=multi_arg_callback,
                      action='callback')
    parser.add_option('-p', '--platform', type='str', dest='platform',
                      default=None,
                      help='Resolved host name for the experiment to run on, '
                      'do not use "localhost"')
    parser.add_option('-i', '--interactive', action='store_true',
                      help='Open any plots in interactive window rather '
                      'saving them to files.', default=False)
    parser.add_option('--plot', action='store_true', default=False,
                      help='Generate plots from results.')
    parser.add_option('--ls', '--list-results', action='store_true',
                      default=False, help='List all stored results. ' +
                      'Experiments and versions to list can be specified ' +
                      'using --experiments and --versions.')
    parser.add_option('--delete', action='store_true', default=False,
                      help='Delete stored results (to be used in ' +
                      'combination with --list-results).')
    parser.add_option('--yes', '-y', action='store_true', default=False,
                      help='Answer yes to any user input')
    parser.add_option('--full-results', '--full', action='store_true',
                      default=False, help='Display all gathered metrics.')
    parser.add_option('--lobf-order', dest='lobf_order', help='The order (int)'
                      'of the line of best fit to be drawn. 0 for no lobf, '
                      '1 for linear, 2 for quadratic ect.', default=2,
                      type='int')
    parser.add_option('--promote', type='str', help='Promote results from an '
                      'older version of an experiment to the current version. '
                      'To be used when making non-functional changes to an '
                      'experiment.')
    parser.add_option('--test', action='store_true', default=False,
                      help='For development purposes, run experiment without '
                      'saving results and regardless of any prior runs.')
    parser.add_option('--markdown', action='store_true', default=False,
                      help='Output data tables in markdown format.')
    opts = parser.parse_args()[0]

    if not opts.experiments:
        opts.experiments = []
    if not opts.versions:
        opts.versions = []

    return opts


def get_schedule(conn, host, versions, experiments, test=False):
    """Determine which experiments to run with which versions.

    Note:
        Profiling only supports running experiments on a single host.

    Return:
        tuple - (schedule, experiments_to_run)
            - platform (str) - Platform to run experiment on.
            - schedule (dict) - Dictionary of cylc version ids containing lists
              of the experiments to run for each.
            - experiments_to_run (set) - Set of (version_id, experiment_id)
              tuples of the experiments to run.
            - runs .... TODO.
    """
    # Generate list of (version_id, experiment_id) tuples for experiment to
    # run.
    experiment_keys = set()
    for experiment in experiments:
        experiment_keys.update(set(itertools.product(
            [host],
            [version['id'] for version in versions],
            [experiment['id']],
            [run['name'] for run in experiment['config']['runs']]
        )))

    # Acquire list of (version_id, experiment_id) tuples for experiments
    # already run.
    result_keys = results.get_keys(conn)

    # Exclude any previously acquired results.
    if test:
        # Don't exclude experiments if in "test" mode.
        experiments_to_run = set(experiment_keys)
    else:
        experiments_to_run = set(experiment_keys) - set(result_keys)

    # Generate list of (version, experiment) tuples for the experiments to run.
    ret = []
    for platform, version_id, experiment_id, run_name in experiments_to_run:
        for version in versions:
            if version['id'] == version_id:
                break
        else:
            raise Exception('Internal error.')
        for experiment in experiments:
            if experiment['id'] == experiment_id:
                break
        else:
            raise Exception('Internal error.')
        ret.append((platform, version, experiment, run_name))
    return ret



def install_experiments(experiments, install_dir):
    """Install experiment dependencies for use in profiling
    
    Args:
        experiments (iterable): Collection of "experiment" dictionaries
            representing each experiment to install.
        install_dir (str): The root profiling directory.
            - Suites will be installed in a "suites" subdirectory.
            - Global configuration files will be installed in a "globalrc"
              subdirectory.
    
    """
    install_sdir = os.path.join(install_dir, 'suites')
    os.mkdir(install_sdir)

    # Install suites.
    suite_dirs = {}
    dont_install = ['passphrase', 'ssl.cert', 'ssl.pem', 'suite.rc.processed']
    for experiment in experiments:
        # Loop over runs and install suites as necessary.
        for run in experiment['config']['runs']:
            sdir = os.path.realpath(run['suite dir'])
            if sdir in suite_dirs:
                # Update configuration to installed suite directory.
                run['suite dir'] = suite_dirs[sdir]
            else:
                # Install suite.
                new_sdir = os.path.join(install_sdir, str(random.random())[2:])
                print 'Installing suite: %s => %s' % (sdir, new_sdir)
                os.mkdir(new_sdir)
                for filepath in glob.glob(os.path.join(sdir, '*')):
                    # Don't install any suite-run files.
                    filename = os.path.basename(filepath)
                    if filename in dont_install:
                        continue
                    try:
                        shutil.copy(filepath, new_sdir)  # Copy file.
                    except IOError:
                        shutil.copytree(filepath,  # Copy directory.
                                        os.path.join(new_sdir, filename))
                suite_dirs[sdir] = new_sdir
                run['suite dir'] = new_sdir

    # Global config sourcing.
    os.mkdir(os.path.join(install_sdir, 'globalrc'))
    for experiment in experiments:
        for run in experiment['config']['runs']:
            if 'globalrc' in run:
                # Run requires a global.rc file - create one from provided
                # key=value pairs.
                string = ''
                for setting in run['globalrc']:
                    indent = 0
                    setting = re.split('[\[\]]+', setting.strip())
                    for part in setting[:-1]:  # Key hierarchy.
                        if not part:
                            continue
                        string += '%s%s%s%s\n' % (
                            '    ' * indent,
                            '[' * (indent + 1),
                            part,
                            ']' * (indent + 1)
                        )
                        indent += 1
                    string += '%s%s\n' % ('    ' * indent, setting[-1])
                # Write out global.rc file.
                hash_ = hashlib.sha256()
                hash_.update(string)
                dirname = os.path.join(install_sdir, 'globalrc',
                                       hash_.hexdigest()[:10])
                if not os.path.exists(dirname):
                    # If an identical globalrc has been written do nothing.
                    os.mkdir(dirname)
                    with open(os.path.join(dirname, 'global.rc'),
                              'w+') as globalrc_file:
                        globalrc_file.write(string)
                run['globalrc'] = dirname


def install_cylc_versions(versions, install_dir):
    """Install cylc versions for use in profiling.
    
    Args:
        versions (iterable): Collection of "version" dictionaries representing
            each cylc version to install.
        install_dir (str): The root profiling directory.
            - Cylc versions will be installed in a "cylc" subdirectory.
            
    """
    os.mkdir(os.path.join(install_dir, 'cylc'))
    for version in versions:
        print 'Installing cylc: %s => %s' % (
            version['name'],
            os.path.join(install_dir, 'cylc', version['name']))
        git.archive_cylc_version(
                version['name'],
                prof.CYLC_DIR,
                os.path.join(install_dir, 'cylc', version['name']))


def run_schedule(conn, schedule, experiments, test=False):
    """Run profiling using the provided schedule.

    Args:
        schedule (iterable): Collection of
            (platform, version, experiment, run_name) tuples to profile.
        test (bool): Results will not be stored if test=True.

    """
    reg_base = 'profile-' + str(time.time()).replace('.', '')
    profiler_install_dir = os.path.join(os.path.expanduser('~'),
                                        'cylc-run',
                                        reg_base)
    os.mkdir(profiler_install_dir)

    # Install cylc versions as necessary.
    install_cylc_versions(
        dict((v['id'], v) for _, v, _, _ in schedule).values(),
        profiler_install_dir)

    # Install experiments as necessary
    install_experiments(
        dict((e['id'], e) for _, _, e, _ in schedule).values(),
        profiler_install_dir)

    # Run profiling.
    prof_results = profile(schedule, profiler_install_dir, reg_base)

    if prof_results is False:
        # Profiling failed, keep install directory.
        return False
    else:
        # Profiling succeeded, tidy up.
        shutil.rmtree(profiler_install_dir)

    # Append results to results file.
    if not test:  # Don't store results in --test mode.
        #append_new_results(results)
        results.add(conn, prof_results, experiments)

    return True


def run_analysis(platform, experiments, versions, interactive=False,
                 quick_analysis=True, lobf_order=2, plot=True, markdown=False):
    """Runs analysis over the results already acquired.

    Args:
        versions (list): List of version dicts.
        experiments (list): List of experiment dicts.
        interactive (bool - optional): If True then interractive matplotlib
            windows will display rather than being rendered to a file.
        quick_analysis (bool - optional): If True then only a small set of the
            gathered metrics will be output.
        lobf_order (int - optional): The polynomial order to be used for
            generating the lines of best fit on all plots produced.
        plot (bool - optional): If True then plotting will be performed.

    """
    # Get results
    #with open(os.path.join(prof.CYLC_DIR,
    #                       prof.PROFILE_DIR_NAME,
    #                       prof.PROFILE_FILE_NAME), 'r') as profile_file:
    #    full_results = json.load(profile_file)

    # Run analysis for each experiment requested.
    for experiment in experiments:
        plt_dir = False
        if not interactive:
            plt_dir = os.path.join(prof.CYLC_DIR,
                                   prof.PROFILE_DIR_NAME,
                                   prof.PROFILE_PLOT_DIR_NAME,
                                   experiment['name'] + '-' +
                                   str(int(time.time())))
            os.makedirs(plt_dir)

        # Print a table of results.
        analysis.results_table(platform, versions, experiment)
        #print
        #kwargs = {'transpose': not quick_analysis}
        #if markdown:
        #    kwargs.update({'seperator': ' | ', 'border': '|', 'headers': True})
        #print_table(
        #    make_table(full_results, versions, experiment,
        #               quick_analysis=quick_analysis), **kwargs)
        #print

        # Plot results.
        if not plot:
            continue
        analysis.plot_results(platform, versions, experiment, plt_dir,
                              quick_analysis=quick_analysis,
                              lobf_order=lobf_order)
        if plt_dir:
            print('Results for experiment "{exp}" have been written out to '
                  '"{dir}"'.format(exp=experiment['name'], dir=plt_dir))


def promote(experiment_id, yes=False):
    """Promote any results for the provided experiment version to the current
    version."""
    if '@' not in experiment_id:
        sys.exit('A version must be supplied to promote an experiment e.g. '
                 'exp@a1b2c3d4e5')
    experiment_name, experiment_version = experiment_id.rsplit('@', 1)

    results = get_results()  # Get contents of results file.

    cur_exp_id = get_experiments([experiment_name])[0]['id']

    candidate_versions = set()
    target_versions = set()
    for host in results:
        for version in results[host]:
            for exp_id in results[version]:
                exp_name, exp_ver = exp_id.rsplit('@', 1)
                if exp_name != experiment_name:
                    continue
                if exp_ver == experiment_version:
                    candidate_versions.add(version)
                elif exp_id == cur_exp_id:
                    target_versions.add(version)

    if not candidate_versions:
        sys.exit('There are no results for experiment "{experiment_id}".'
                 ''.format(experiment_id=experiment_id))
    ls([experiment_name], [])
    if target_versions:
        candidate_versions = [version for version in candidate_versions if
                              version not in target_versions]
        print
        print('Only the results for cylc versions not already profiled in '
              'the current experiment version will be promoted.')
    git.order_identifiers_by_date(candidate_versions)

    print
    print('Promote the following results for experiment "{name}" at version '
          '"{candidate}" to the current version "{target}":'.format(
              name=experiment_name,
              candidate=experiment_version,
              target=cur_exp_id.rsplit('@', 1)[1]
          ))
    print '\t', ' '.join(candidate_versions)

    if not yes:
        response = None
        while response not in ['y', 'n']:
            response = raw_input('Upgrade these versions? (y/n): ')
    if yes or response == 'y':
        # Promote results.
        try:
            for host in results:
                for version in candidate_versions:
                    results[host][version][cur_exp_id] = (
                        results[version][experiment_id])
        except KeyError as exc:
            print exc
            sys.exit('Unexpected error.')
        else:
            append_new_results(results)
        # Provide option to delete duplicates.
        ls([experiment_id], candidate_versions, delete=True)
    else:
        sys.exit('Aborted, not changes made.')


def ls(conn, platform, version_refs, experiment_names, delete=False):
    # Get list of version_ids from version identifiers.
    version_ids = [git.describe(version) for version in version_refs]

    # Get dictionary for converting beteen experiment names and ids.
    if experiment_names:
        exp_id_dict = results.get_experiment_ids(conn, experiment_names)

    # Get list of experiment_ids from experiment names.
    experiment_ids = []
    for exp_name in experiment_names:
        try:
            # Obtain experiment_id from expeirment_name.
            experiment_ids.extend(exp_id_dict[exp_name])
        except KeyError:
            # Not a valid expeiment name, treat it as an id.
            experiment_ids.append(exp_name)

    # Print results
    results.print_list(conn, platform, version_ids, experiment_ids)
    if not delete:
        return

    # If we are in delete mode prompt the user to delete the displayed results.
    usr = None
    while usr not in ['y', 'n']:
        usr = raw_input('\nDelete these results (y/n)? ')
    if usr != 'y':
        return

    # Delete the results.
    results.remove(conn, platform, version_ids, experiment_ids)


def main():
    """Implement `cylc profile-battery`."""
    opts = parse_args()
    if not prof.IS_GIT_REPO:
        print >> sys.stderr, ('ERROR: profiling requires cylc to be a git '
                              'repository.')
        sys.exit(2)

    profile_dir = os.path.join(prof.CYLC_DIR, prof.PROFILE_DIR_NAME)
    if not os.path.exists(profile_dir):
        print 'Creating profiling directory.'
        os.mkdir(profile_dir)
        os.mkdir(os.path.join(profile_dir, prof.PROFILE_PLOT_DIR_NAME))
        os.mkdir(os.path.join(profile_dir, prof.USER_EXPERIMENT_DIR_NAME))
    profile_dir = os.path.join(prof.CYLC_DIR, prof.PROFILE_DIR_NAME)
    db_file = os.path.join(profile_dir, prof.PROFILE_DB)
    conn = results.get_conn(db_file)

    # Promote mode.
    #if opts.promote:
    #    promote(opts.promote, opts.yes)
    #    sys.exit(0)

    # If in "list" mode print out results then exit.
    if opts.ls or opts.delete:
        ls(conn, opts.platform, opts.versions, opts.experiments, opts.delete)
        sys.exit(0)

    platform = opts.platform or socket.gethostname()

    # Fail if no experiments / versions provided ...
    if not opts.experiments or not opts.versions:
        sys.exit('Provide at least one experment and one version '
                 'to perform profiling.')

    # Generate list of requested experiments and versions.
    experiments = prof.get_experiments(opts.experiments)
    versions = prof.get_versions(opts.versions)

    # Order versions.
    git.order_versions_by_date(versions)

    # Fail in the event that an experiment file cannot be found.
    if not all([experiment['file'] for experiment in experiments]):
        sys.exit('Experiment file(s) could not be loaded, profiling aborted.')

    # Run experiments as necessary.
    schedule = get_schedule(conn, platform, versions, experiments,
                            test=opts.test)
    if schedule:
        if not run_schedule(conn, schedule, experiments, opts.test):
            sys.exit('Profiling failed.')

    # Don't run analysis if in "test" mode.
    if opts.test:
        sys.exit(0)

    # Run analysis
    #run_analysis(platform,
    #             experiments,
    #             versions,
    #             interactive=opts.interactive,
    #             quick_analysis=not opts.full_results,
    #             lobf_order=opts.lobf_order,
    #             plot=not opts.no_plots,  NOTE: Now opts.plot
    #             markdown=opts.markdown)

    # Output results.
    for experiment in experiments:
        # Print results table.
        results.print_result(conn,
                             platform,
                             versions,
                             experiment,
                             quick_analysis=not opts.full_results,
                             markdown=opts.markdown)
        if opts.plot:
            # Plot results.
            if not opts.interactive:
                plot_dir = make_plot_dir(experiment['name'])
            else:
                plot_dir = False
            results.plot_result(conn,
                                 platform,
                                 versions,
                                 experiment,
                                 plot_dir,
                                 quick_analysis=not opts.full_results,
                                 lobf_order=opts.lobf_order)
            if plot_dir:
                print 'Plots written out to "%s"' % plot_dir


def make_plot_dir(experiment_name):
    """Make and return the path to a directory for an experiments plots."""
    dirname = os.path.join(
        prof.CYLC_DIR,
        prof.PROFILE_DIR_NAME,
        prof.PROFILE_PLOT_DIR_NAME,
        '%s-%s' % (experiment_name, str(time.time()).split('.')[0]))
    os.mkdir(dirname)
    return dirname


if __name__ == '__main__':
    main()
